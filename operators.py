#Объект это именованная область памяти

# В структурной парадигме программа состоит из 3 управляющих конструкций:
# последовательность,
# ветвление,
# цикл
# Также возможно использование подпрограмм, а сама программа выполняется сверху
# вниз

# Переменная это интерфейс для изменения значения объекта, определяется
# идентификатором (уникальным именем) и ссылкой на объект
# Здесь создается объект со значением 7, затем на него ссылается переменная a
a = 7

# Чтобы создать объект, нужно выделить память, с которой программа имеет право
# работать. Когда количество ссылок на объект достигает нуля, объект удаляется,
# а память высвобождается.

# Здесь мы не указываем тип переменной, это называется неявной типизацией
# Также переменная может ссылаться на объект другого типа, это называется
# динамической типизацией (тип определяется в момент присвоения, **во время
# работы программы**)
a = 8

# Важно обратить внимание на то, что в питоне все переменные **ссылаются** на
# объект, если одну переменную присвоить другой, новый объект не будет создан
b = a
c = 8  # тоже ссылка на ранее созданный объект
# Встроенная функция id возвращает идентификатор объекта
print(id(b) == id(a))  # True
print(id(b) == id(c))  # True

aa = 'hello'
bb = 'hello'
print(id(aa) == id(bb))  # True


# Каскадное присвоение
a = b = c = 2
print(a, b, c)  # 2, 2, 2

# Множественное присваивание
a, b = 1, 2
print(a, b)  # 1, 2

# Можно делать такую перестановку
a, b = b, a
print(a, b)  # 2, 1


# Получить тип данных (класс) при помощи встроенной функции
t = type(a)
print(t)  # <class 'int'>


# Идентификатор может состоять из цифр, латинских букв и нижнего подчеркиваиня.
# Но цифра недопустима в качестве первого символа.
# Имена чувствительны к регистру

# Типы чисел
a = 3
print(type(a))
b = 3.3
print(type(b))
c = 3 + 3j
print(type(c))

# Арифметические операции (последовательность одинаковых или с одинаковым
# приоритетом) выполняются слева
# направа, кроме возвредения в тепень. Если операции в выражении разные, то
# следует учитывать приоритет операций.
print(32 / 4 * 2)   # 16.0 (слева направо)
# Здесь создается 3 объекта, их значение суммируется, создается 4 объект,
# предыдущие удаляются, если на них не было ссылок
a = 1 + 2 + 3

# Деление

a = 1 / 2
print(a)  # 0.5
# Целочисленное деление (деление с округлением к **наименьшему** целому)
a = 1 // 2
print(a)  # 0
print(type(a))  # <class 'int'>
a = -1 // 2
print(a)  # -1


# В математике:
# x = ab + r, где 0 <= r < |b|, остаток от деления, b -- делитель
# В питоне **знак остатка совпадает со знаком делителя**, поэтому для отицательного
# делителя стандартная формула не справедлива
print(10 % 3)  # x % b -> a = 3, r = 1
print(2 % 3)  # 2
print(-2 % 3)  # a = -1, r = 1

print(2 % -3) # a = -1, r = -1
print(-2 % -3)  # -2


# Степень (корень -- для дробных)

print(2 ** 3 ** 0)  # 2 = 2^(3^0) -- справа налево
# Можно заменить встроенной функцией
print(2 ** pow(3, 0))


# Все арифметически операторы можно записывать в унарной форме
a = 3
a += 1
# Инкременты и декременты отсутствуют
print('here', a)  # 4
#a++
print(++a)  # 4, ведет себя как +(+a)
#print(++a)
#print(a)

# Как в жсе используется дополнительный код
print(~-1)  # 0




# Просто убирает отрицание с сохранением типа
print(abs(-5), abs(-5.6))  # 5 5.6

# Один аргумент писать нельзя
print(min(1, 2, -0.1))  # -0.1
print(max(0, 1, -1))  # 1


print('округление по банковским правилам (не математическим), к ближайшему четному')
print(round(1.5))  # 2
print(round(2.5))  # 2
# Можно указать разряд, до которого округлять
# Из-за неточного предсталения дробных числел может возникнуть неожиданное
# поведение:
print(round(2.675, 2))  # 2.67

from decimal import Decimal

dd = Decimal(2.675)
print(dd) # 2.6749999999999998...
d = Decimal('2.675')
print(round(d, 2))  # 2.68

# round возвращает целое, если точность (второй аргумент) не указана и
# сохраняет тип, если указана
res = round(1, 2)
print(res, type(res))  # 1 <class 'int'>


# можно использовать отрицательную точность, чтобы округлять целые
print(round(Decimal(66), -1))  # 70


# округление к верхнему целому
# math.ceil

# округление к нижнему целому (целочисленное деление)
# math.floor(-.5)

#math.factorial(3) # 1 * 2 * 3

#math.trunc(5.8)  # отбросить дробную часть, аналог int()

# math.log2(4), math.log10(1000), math.log(2.7) натуральный, math.log(27, 3)
# math.sqrt(49)  # корень
# math.pi, math.e  константы:q
