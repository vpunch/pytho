# Существует множество встроенных классов, которые принято писать с маленькой
# буквы: int, float, list, dict, type и т.д.

# Класс-наследник может либо расширять (extend), либо переопределять (override)
# базовый класс. В первом случае добавляются новые атрибуты, во втором --
# определяются атрибуты с тем же именем

# Классы тоже являются объектами, поэтому объекты, которые порождают обычные
# классы (потому что есть еще метаклассы), будем называть **экземплярами**

# Все определяемые классы неявно наследуют тип object
class A:
    """Описание класса."""

    # Статический метод отличается от обычного метода и метода класса тем, что
    # не связывается ни с экземпляром, ни с объектом класса
    # Но его как и classmethod можно вызывать из объекта класса или экземпляра
    @staticmethod
    def validate_int(value):
        if not isinstance(value, int):
            raise TypeError(f'{value} должно быть int')

        return value

    # Внутри класса определяются **атрибуты**, которые могут быть полями или
    # методами

    # Не забываем, что тело класса образует пространство имен, здесь мы
    # находимся внутри него и можем обращаться ко всем переменным и функциям
    # напрямую, без использования объекта класса (здесь он еще в процессе
    # определения) или экземпляра
    distance = validate_int(10)
    color = 'red'
    # _ используется, чтобы **показать**, что атрибут защищенный. Фактически
    # это никак не ограничивает к нему доступ.
    _valid_colors = ['black', 'red', 'white']
    __pvt_cls = True

    # Методу класса неявно передается объект класса cls вместо self при вызове
    # из объекта класса или экземпляра класса
    # Можно также использовать для определения дополнительных конструкторов,
    # так как если мы напишем еще один __init__, то он просто перекроет старый
    @classmethod
    def check_color(cls, color):
        return color in cls._valid_colors

    # Методы это функции, в которые неявно передается экземпляр, из которого
    # вызывался метод
    # Если метод вызывается из самого класса, то никакие аргументы неявно
    # передаваться не будут
    def add_color(self, name):
        self._valid_colors.append(name)

    # Имитация абстрактного метода, выбросит ислючение при вызове
    def get_food():
        raise NotImplementedError('Метод не реализован')

    # __ используется, чтобы сделать атрибут (не обязательно метод) приватным
    # Интерпретатор неявно заменит имя атрибута на _<class><attr>, чтобы мы
    # не смогли обратиться к нему вне тела класса. <class> -- это имя того
    # класса, в котором мы в данный момент находимся.
    # Манглинг помогает защитить атрибут от переопределения в дочерних классах
    def __set_x(self):
        self.x = 1

    def set_y(self):
        self.y = 1

    # Конструктор, который создает и возвращает новый объект
    def __new__(cls,          # объект класса
                *args,        # позиционные аргументы, переданные при создании
                              # экземпляра
                **key_args):  # именованные аргументы
        # Можно не определять явно, конструктор будет взят из базового класса

        return super().__new__(cls)

    # **Инициализатор**, который заполняет новый объект self
    def __init__(self, color='black'):
        # Имеется пустой у object, определять не обязательно

        if self.check_color(color):
        #if A.check_color(name):  # так лучше не писать, чтобы не
                                  # привязываться к имени класса
            self.color = color

        self.__set_x()  # этот метод нельзя переопределить
        self.set_y()    # может быть переопределен

        self.__pvt_inst = True

        # Вызов инициализатора MixinLog
        super().__init__()

        # Из инициализатора можно спокойно выбрасывать исключения, которые
        # нужно будет обработать при создании экземпляра


# Фактически класс образует пространство имен, внутри которого мы определяем
# переменные, к которым можем обращаться
print('Доступ к содержимому класса')
# Оно неявно хранится в словаре, доступ к которому можно получить при помощи
# магического поля
print(A.__dict__)  # {'__doc__': 'Описание класса', ..., 'color': 'red'}

print('\nСоздание экземпляра класса')
a1 = A()
# Экземпляр класса имеет свой скрытый словарь, который мы можем заполнить
# динамически, например, в инициализаторе
# Можно обратить внимание, что экземпляр не содержит никаких скрытых (
# магических) атрибутов
# {'color': 'black', 'x': 1, 'y': 1, '_A__pvt_inst': True} black
print(a1.__dict__, a1.color)

print('\nПубличный доступ к приватному атрибуту')
# Не имеет значения, принадлежит атрибут экземпляру или классу, правила
# именования одинаковы
print(a1._A__pvt_cls, a1._A__pvt_inst)  # True True

print('\nПолучить класс объекта можно специальной функцией')
a2 = type(a1)('white')
print(a2.color)  # white
# Либо при помощи магического поля (к магическим атрибутам обращаться не
# рекомендуется)
print(a1.__class__)  # <class '__main__.A'>


class MixinLog:
    def __init__(self):
        self.__counter = 0

    def save_log(self):
        self.__counter += 1
        print(f'Logged {self.__counter}')


# Круглые скобки после имени класса это вызов __call__() из **метакласса**
# Сам класс является экземпляром метакласса, и у него **своя цепочка**
# наследования

# Класс B наследует A и MixinLog
# O-принцип SOLID: мы должны расширять, а не изменять

# Множественное наследование позволяет **расширить поведение** существующего
# класса, и нам не придется менять класс на дочерний в коде. Но для
# **переопределения** придется наследовать новый класс.

# При множественном наследовании используется алгоритм MRO (Method Resolution
# Order) для обхода базовых классов
# Основным родителем считается первый класс в списке, он всегда будет первым в
# цепочке базовых классов при поиске атрибута
# Остальные родительские классы являются вспомогательными, их называют
# примесями, они не должны иметь своих параметров в инициализаторе, потому что
# их порядок может быть разным
class B(A, MixinLog):
    # Вложенные классы хранятся в виде объекта внутри объекта своего класса
    # Удобно использовать, чтобы показать, что класс нужен для работы
    # конкретному классу
    class Inner:
        inner_a = 'a'

    __pvt_b_cls = True

    # Все отсутствующие локальные атрибуты будут искаться в унаследованных
    # объектах

    # Мы можем вызывать методы из суперкласса, определенные в подклассах, но
    # так делать не стоит, так как базовый класс ничего не должен знать о
    # наследниках

    # Финализатор
    # Вызывается **перед** удалением объекта
    def __del__(self):
        # Сборщик мусора будет вызывать этот метод, когда программа завершится

        # Не определяется пустым по умолчанию
        #super().__del__()  # object has no attribute '__del__'

        print(f'Финализация {self}')

    # Реализация абстрактного метода родительского класса
    def get_food():
        return 'Лазанья'

    def __init__(self):
        # super() возвращает не родительский объект, а делегатор для него
        super().__init__()
        # Можем явно вызывать родительский инициализатор, но так делать не
        # стоит, так как мы привязываемся к имени класса и можем получить цикл,
        # который разрешает MRO
        #  --> A ->
        #  |      |  ->  B -> A -> C
        #  B. <-- C      связь C -> B можем удалить, так как B уже проверили
        #A.__init__(self...)

        self.__pvt_b_inst = True

    def __set_x(self):
        self.x = 10

    def set_y(self):
        self.y = 10


b1 = B()
b2 = B()

print('\nMethod Resolution Order')
# Экземпляр не имеет доступ к цепочке родителей
#b1.__mro__  # error: object has no attribute '__mro__'
# Вернет список объектов-классов, которые последовательно обходятся при поиске
# атрибута
print(B.__mro__)

B.distance = 5  # сейчас оба объекта ссылаются на один и тот же атрибут
                # класса, который (атрибут) мы изменили

print('\nСначала ищем в самом объекте, потом в его классе и предках этого '
      + 'класса')
print(b1.distance)  # 5
print(b2.distance)  # 5
# Мы можем назначить экземплярам собственный атрибут в инициализаторе, чтобы
# избежать такого поведения

print('\nПриватный метод не был переопределен')
print(b1.x, b1.y)  # 1 10

print('\nСписок всех доступных атрибутов (включая унаследованные) можно '
      + 'получить так')
# Не все магические атрибуты наследуются
print(dir(b1))

print('\nТестируем примесь')
b1.save_log()  # Logged 1

print('\nДинамическое создание атрибутов (после создания объекта)')
b1.phrase = 'hello, world'
# Или при помощи функции
setattr(b1, 'number', 3)
# Методы тоже можно создавать динамически, но их нужно присваивать классу, а не
# экземпляру
B.print_number = lambda self: print(self.number)
b1.print_number()   # 3
print(b1.__dict__)  # {..., 'phrase': 'hello, world', 'number': 3}
# В словаре видно поле из примеси

print('\nЧтение атрибутов')
#b1.invalid  # error: object has no attribute 'invalid'
# Поиск будет выполняться и в родительских объектах
print(getattr(b1, 'distance'))  # 5
# Бросит ошибку, если не будет найден, но можем указать значение по умолчанию
print(getattr(b1, 'invalid', None))  # None
# В отличие от js, мы не теряем контекст функции, когда вызываем ее не из
# экземпляра
foo = b1.print_number
foo()  # 3
# getattr также возвращает функцию уже связанную с экземпляром
# <**bound** method <lambda> of <__main__.B1 object ...>>
print(getattr(b1, 'print_number'))

print('\nПоиск атрибута')
print(hasattr(b1, 'distance'))  # True

print('\nУдаление атрибута')
# Эта операция не затрагивает родительские объекты
del b1.number
#del b1.number            # AttributeError
#delattr(b1, 'distance')  # AttributeError
# Переменная удаляется таким же образом, так как она является атрибутом
# globals()

print(('\nВстроенной функцией мы можем проверить, является ли объект '
       'экземпляром класса'))
print(isinstance(b1, B))        # True
print(isinstance(b1, A))        # True
print(isinstance(b1, object))   # True
print(isinstance(object(), B))  # False

print('\nТак можно проверить, является ли класс дочерним')
print(issubclass(B, A))       # True
print(issubclass(B, object))  # True

# Метод неявно связывается только с экземпляром, но не с объектом самого класса
# Это позволяет нам передать контекст самостоятельно
# Этот трюк можно использовать, чтобы вызывать метод из базового класса,
# который переопределяется другим базовым классом
#A.add_color('yellow')  # error: missing 1 required positional argument
A.add_color(a1, 'yellow')
print('Но метод класса связывается с объектом класса')
print(A.check_color('gray'))  # False

print('\nВложенный класс')
# У экземпляров внутреннего класса не будет поиска атрибутов во
# внешнем классе
inner = B.Inner()
print(dir(inner))
# А у экземпляра внешнего класса не будет поиска атрибутов во внутреннем
# классе
#b2.inner_a  # error: object has no attribute
# Но это можно сделать явно
print(b2.Inner.inner_a)  # a

print('\nМы можем вызывать super вне тела класса')
del b2.y
#print(b2.y)  # AttributeError
super(
    B,  # **в родителях** какого класса выполнять поиск (по умолчанию
        # self.__class__)
    b2  # контекст для вызываемых методов (по умолчанию self)
).set_y()
# Для super обязательно должно выполняться isinstance(context, class)
print(b2.y)  # 1
